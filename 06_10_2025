//The Knight's tour problem
import java.util.*;

class Solution {
    // All possible moves for a knight
    private static int[] dx = {2, 1, -1, -2, -2, -1, 1, 2};
    private static int[] dy = {1, 2, 2, 1, -1, -2, -2, -1};
    
    public ArrayList<ArrayList<Integer>> knightTour(int n) {
        // Create result matrix
        int[][] board = new int[n][n];
        
        // Initialize board with -1 (unvisited)
        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i], -1);
        }
        
        // Start from (0,0) with move count 0
        board[0][0] = 0;
        
        // Try to find knight's tour
        if (solveKnightTour(board, 0, 0, 1, n)) {
            return convertToResult(board, n);
        } else {
            return new ArrayList<>();
        }
    }
    
    private boolean solveKnightTour(int[][] board, int x, int y, int moveCount, int n) {
        // If all cells are visited, we found a solution
        if (moveCount == n * n) {
            return true;
        }
        
        // Get all possible next moves sorted by accessibility (Warnsdorff's heuristic)
        List<int[]> nextMoves = getNextMoves(board, x, y, n);
        
        // Try all possible next moves
        for (int[] move : nextMoves) {
            int nextX = move[0];
            int nextY = move[1];
            
            // Mark this cell as visited
            board[nextX][nextY] = moveCount;
            
            // Recursively check if this leads to a solution
            if (solveKnightTour(board, nextX, nextY, moveCount + 1, n)) {
                return true;
            }
            
            // Backtrack if this move doesn't lead to a solution
            board[nextX][nextY] = -1;
        }
        
        return false;
    }
    
    private List<int[]> getNextMoves(int[][] board, int x, int y, int n) {
        List<int[]> moves = new ArrayList<>();
        
        // Generate all possible knight moves
        for (int i = 0; i < 8; i++) {
            int nextX = x + dx[i];
            int nextY = y + dy[i];
            
            // Check if move is valid and cell is unvisited
            if (isValidMove(nextX, nextY, n) && board[nextX][nextY] == -1) {
                moves.add(new int[]{nextX, nextY});
            }
        }
        
        // Sort moves by number of onward moves (Warnsdorff's heuristic)
        moves.sort((a, b) -> {
            return countOnwardMoves(board, a[0], a[1], n) - 
                   countOnwardMoves(board, b[0], b[1], n);
        });
        
        return moves;
    }
    
    private int countOnwardMoves(int[][] board, int x, int y, int n) {
        int count = 0;
        
        for (int i = 0; i < 8; i++) {
            int nextX = x + dx[i];
            int nextY = y + dy[i];
            
            if (isValidMove(nextX, nextY, n) && board[nextX][nextY] == -1) {
                count++;
            }
        }
        
        return count;
    }
    
    private boolean isValidMove(int x, int y, int n) {
        return x >= 0 && x < n && y >= 0 && y < n;
    }
    
    private ArrayList<ArrayList<Integer>> convertToResult(int[][] board, int n) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<>();
        
        for (int i = 0; i < n; i++) {
            ArrayList<Integer> row = new ArrayList<>();
            for (int j = 0; j < n; j++) {
                row.add(board[i][j]);
            }
            result.add(row);
        }
        
        return result;
    }
}